{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About flute","text":""},{"location":"#what-is-flute","title":"What is flute?","text":"<p>Flute is a C++20 fixed-point library. It aims to provide a  modern interface that allows to deal with fixed-point arithmetic. It is  meant to be used on systems that don't have an FPU (floating-point unit), such as micro-controllers.</p> <p>Flute is a bit different from other fixed-point libraries. It includes utilities for look-up tables (LUT, hence the name \"flute\").</p>"},{"location":"#basic-example","title":"Basic example","text":"<p>Here is a simple example that shows how to use the library:</p> <pre><code>#include \"flute.hpp\"\n\nint main()\n{\n  using namespace flute;\n\n  constexpr ufixed&lt;16,16&gt; pi{3.1415926};\n  constexpr auto two_pi = 2 * pi;\n\n  static_assert((two_pi - pi).as&lt;double&gt;() == pi.as&lt;double&gt;());\n}\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Zero-overhead: You only pay for what you need. For instance (real-world example), compiling for an ARM Cortex-M3 using GCC 13.2, flute allows to multiply an integer and a <code>ufixed&lt;12, 20&gt;</code> as fast as a regular 32-bit integer multiplication. Compared to multiplying an integer with a 32-bit float, this allows to save about 1277 bytes in the compiled firmware.</li> <li>Embedded-friendly: The STL is not required. Flute only needs a few C++ headers: <code>array</code>, <code>concepts</code>, <code>limits</code>, and <code>type_traits</code>.</li> <li>Modern C++ standards: Requires C++20. Concepts make the code more reliable and provide readable error messages. Moreover, modern C++ is key to achieve optimal performance.</li> <li>Compile-time evaluation: Everything is constexpr! This has a very positive impact on performance too.</li> <li>Header-only library: No need to link the library, simply include <code>flute.hpp</code> into your .cpp files.</li> <li>Policy-based design: Some fixed-point operations require to make choices, especially regarding overflow.</li> </ul>"},{"location":"#how-to-use","title":"How to use","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Since this is a header only library, all you need is a C++20 compiler. This library has only been tested with GCC 13.2 (x86-64 and arm-none-eabi). It should compile with GCC 10 and Clang 16.</p>"},{"location":"#using-the-library","title":"Using the library","text":"<p>Flute is a header-only library, so all you need to do is include <code>flute.hpp</code> into your C++ files.</p>"},{"location":"fixed_point_numbers/","title":"Fixed-point numbers","text":""},{"location":"fixed_point_numbers/#what-are-fixed-point-numbers","title":"What are fixed-point numbers?","text":"<p>In essence, fixed-point numbers are a very simple representation of rational (non-integer) numbers. The idea is that there is a fixed number of digits representing the fractional part of a number. The same goes for the integer part, so a fixed-point number can be: 12.75, where 12 is the integer part and 75 the fractional part. In this example, if there are always two digits before and after the point, we call that a fixed-point number, at least in base 10.</p>"},{"location":"fixed_point_numbers/#why-use-fixed-point-numbers","title":"Why use fixed-point numbers?","text":"<p>Fixed-point numbers are mostly useful in the embedded world, where some micro-controllers don't have a floating point unit (FPU), that is: they don't have the required hardware to perform floating-point operations. On those micro-controllers, floating-point arithmetic is still possible, but it is very slow.</p> <p>On the other hand, fixed-point numbers are very simple. Their simplicity is also the reason why they are pretty fast for basic arithmetic operations. They also allow to choose the position of the radix point, which can be very convenient.</p>"},{"location":"fixed_point_numbers/#q-notation","title":"\\(Q\\) notation","text":"<p>The \\(Q\\) notation is often used to represent binary fixed-point numbers. Imagine that we have a 8-bit micro-controller and want to perform some non-integer computations. To that end, we need parameter that goes from \\(0\\) to \\(10\\), with a step of \\(0.1\\).</p> <p>To satisfy those conditions, we need the integer part to go from \\(0\\) to, at least, \\(10\\), and the fractional part to have a smallest value lower than 0.1, that is \\(\\leq2^{-4}\\), as \\(2^{-4} = 0.0625\\).</p> <p>The \\(Q\\) notation comes in handy, in that it lets use represent such a number as: \\(UQi.f\\), where \\(i\\) is the integer part, and \\(f\\) the fractional part of the number we wish to represent. The \\(U\\) prefix means that we are dealing with unsigned numbers. To meet our example's requirements, we need to have a \\(UQ4.4\\) number.</p> <p>Of course, a \\(UQ4.4\\) number is stored as a single byte.</p>"},{"location":"fixed_point_numbers/#range-of-fixed-point-numbers","title":"Range of fixed-point numbers","text":"<p>One of the most important properties of fixed-point numbers is their range. The minimum value of an unsigned fixed-point number is \\(0\\). However, the maximum value depends on both its integer part \\(i\\), and its fractional part \\(f\\). The maximum value corresponding to the integer part is \\(2^i - 1\\), to which we must add the maximum of the fractional part: \\(1 - 2^{-f}\\). Adding the two values leads to: $$ 0 \\leq UQi.f \\leq 2^i - 2^f.$$ For instance, the maximum value of a \\(Q4.4\\) number is \\(2^4 - 2^{-4} = 16 - \\frac{1}{16} = 15.9375.\\)</p> <p>Now, if we consider signed fixed-point numbers, the minimum value becomes \\(-2^{i - 1}\\), which is the same as a regular signed integer. The maximum value, is \\(2^{i - 1} - 2^{-f}\\). A signed number's most significant bit holds the sign, so a \\(Q3.4\\) fixed-point number requires 8 bits of data<sup>1</sup>.</p> <p>We can see that, for a signed fixed-point, the following applies: $$ -2^{i - 1} \\leq Qi.f \\leq 2^{i - 1} - 2^{-f}. $$ For instance, a \\(Q3.4\\) number goes from \\(-2^2 = -4\\) to \\(2^2 - 2^{-4} = 3.9375\\).</p>"},{"location":"fixed_point_numbers/#precision-of-fixed-point-numbers","title":"Precision of fixed-point numbers","text":"<p>The precision of a fixed-point solely defined by its number of fractional bits: $$ \\epsilon(Qi.f) = 2^{-f}. $$</p>"},{"location":"fixed_point_numbers/#internal-representation","title":"Internal representation","text":"<ol> <li> <p>This is the Texas Instruments notation.\u00a0\u21a9</p> </li> </ol>"},{"location":"flute_tutorial/","title":"Flute tutorial","text":""}]}